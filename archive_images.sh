#!/bin/bash

# archive_images.sh - consolidates, ompresses and moves image files to for_archive directory

#   run using ./ not sh

# declare constants, variables and arrays

declare -r unk="unknown";
declare -r fil="files";
declare -r emp="empty";
declare -r ntf="not_found";
declare -r rbn="/home/master/render_bin";
declare -r com="/home/master/compositing";
declare -r tmp="/home/master/tmp";
declare -r far="/home/master/for_archive";
declare -a blender_files;

# set colour variables
green="\033[0;32m"
yellow="\033[0;33m"
blue="\033[0;34m"
clear="\033[0m"

# define user functions

# function error_exit checks return code and exits 
error_exit () {
  echo
  echo "$1"
  echo -e ${yellow};
  echo "Exiting ..........";
  echo -e ${clear};
  sleep 3;
  exit 1;
}

# function confirm prompts user to confirm input or selection
confirm() {
  echo
  read -p "Confirm (Y/y)? " -n 1 -r;
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    error_exit "No confirmation";
  fi  
}

# function contin prompts user to continue to next
contin() {
  echo
  read -p "Continue (Y/y)? " -n 1 -r;
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo
    echo -e ${green};
    echo "Exiting ..........";
    echo -e ${clear};
    exit 0;
  fi  
}

# function check empty checks there are no files or directories present
check_empty() {
  if [ -n "$(find $1 -maxdepth 0 -empty 2> /dev/null)" ]; then  
    status=$emp;
  else
    status=$fil;
  fi 
}

# function delete_spurious - deletes spurious files from a directory
# Note1: Spurious files are files that will have a determinetal effect on Blender
# when loading images for compositing.  Spurious files include empty files
# and hidden .DS_Store files generated by file manager applications such as Finder.
# Note2: Although potentially dangerous the '*' method is necessary because
# suffixes are added to multiple files e.g ".DS_Store" "._.DS_Store"...

delete_spurious () {
cd $1
`find . -name '*.DS_Store' -type f -delete`;
cd $2;
}

# function remove_hidden - removes all hiddent files and directories

remove_hidden() {
  cd $1;
  if [[ -n $(find . -mindepth 1 -name '.*') ]]; then
    echo "Hidden files found";
    find . -mindepth 1 -name '.*';
    echo
    echo "Removing hidden files";
    rm -rf .* 2> /dev/null;   
  else
    echo
    echo "No hidden files found";
  fi
  cd $2
}

# function move_file uses cp-rm - moves file (1) from source (2) to dest (3)
move_file() {
  if [ -f "$3/$1" ]; then
    error_exit "Duplicate file $infile";
  else
     if cp "$2/$1" "$3"; then
       rm "$2/$1";
     fi
fi
}

# function tar_files - compresses all files in a directory to a tar archive
tar_files() {
  cd $1
  seq_name=`ls -1 | head -n1`;
  tar_file=$(echo $seq_name | cut -d'-' -f1);
  tar -zcvf "${tar_file}.tar.gz" *;
  tar_file="${tar_file}.tar.gz";
  cd $rbn
}

# function clear_directory - deletes all files from a directory

clear_directory() {
  cd /home/master/compositing;
  rm -r $tar_name*.*;
  cd $rbn
}

###
# Display run notice
###

echo -e ${blue};
clear
echo
echo "     ******************"
echo "     * ARCHIVE IMAGES *"
echo "     ******************"
echo
echo "     Deletes all hidden files in compositing and for_archive directories,"
echo "     Consolidates (tar) all files,"  
echo "     compresses (gz) all files,";
echo "     moves compressed file to for-archive directory,"
echo "     and deletes all iage files from compositing directory"
echo
echo -e ${clear};
contin 

cd ~/render_bin;

# Delete any spurious hidden files

echo
echo "Deleting spurious and hidden files ..........";
echo

remove_hidden $com $rbn;

remove_hidden $far $rbn;

###
# Check status of source directory
###

echo
echo "Checking Compositing directory status ..........";
echo

status="$unk";

check_empty "$com";

if [ "$status" = "$emp" ]; then
  error_exit "$com status is $status";
else
  echo "$com status is $status";
fi

###
# Compress all files in compositing directory
###

tar_files $com;

# move compressed file

move_file $tar_file $com $far;

# clear out compositing directory

clear_directory;

echo
echo "Moved $tar_file to $far";
echo
echo -e ${green};
echo "Exiting ..........";
echo -e ${clear};
sleep 3  
 
exit 0








